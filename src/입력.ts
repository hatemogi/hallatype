/**
 * 한글 두벌식 오토마타 구현
 */

import { 초성, 중성, 종성 } from './한글';
import { 글자꼴, 글자없음 } from './글자';

export enum 상태코드 {
    S0  = '시작상태',
    S10 = '초성단자음',
    S11 = '초성복자음',
    S20 = '중성기본',   // 두벌식 키 하나로 입력하는 모음
    S21 = '중성조합',   // 두벌식 키 두번 눌러서 입력하는 모음
    S30 = '종성단일',   // 쌍자음 포함 한 키로 입력하는 자음
    S31 = '종성자음군', // 자음 키 두 번 눌러서 입력하는 받침
}

export enum 위치이동 {
    이전 = '이전',
    유지 = '유지',
    다음 = '다음',
}

export enum 입력모드 {
    한글 = '한글모드',
    종성없음 = '종성없음',
    영문 = '영문모드',
}
export type 키입력 = [입력모드, boolean, string];
export type 머신상태 = [상태코드, 글자꼴[], 글자꼴];
type 다음상태 = [위치이동, 상태코드, 글자꼴[], 글자꼴];

const 자음키맵 = new Map<string, number>([
    ['Q', 초성.ㅂ], ['W', 초성.ㅈ], ['E', 초성.ㄷ], ['R', 초성.ㄱ], ['T', 초성.ㅅ],
    ['A', 초성.ㅁ], ['S', 초성.ㄴ], ['D', 초성.ㅇ], ['F', 초성.ㄹ], ['G', 초성.ㅎ],
    ['Z', 초성.ㅋ], ['X', 초성.ㅌ], ['C', 초성.ㅊ], ['V', 초성.ㅍ]]);
const 초성to종성: ReadonlyArray<[number, number]> = [
    [초성.없음, 종성.없음], [초성.ㄱ, 종성.ㄱ], [초성.ㄲ, 종성.ㄲ], [초성.ㄴ, 종성.ㄴ], [초성.ㄷ, 종성.ㄷ],
    [5, 0], [6, 8], [7, 16], [8, 17], [9, 18],
    [10, 19], [11, 20], [12, 21], [13, 22], [14, 0],
    [15, 23], [16, 24], [17, 25], [18, 26], [19, 27],
];
const 초성to종성맵 = new Map<number, number>(초성to종성);
const 종성to초성맵 = new Map<number, number>(
    초성to종성.map((초종) => 초종.reverse() as [number, number]));
const 쌍자음키맵 = new Map<string, number>([
    ['Q', 초성.ㅃ], ['W', 초성.ㅉ], ['E', 초성.ㄸ], ['R', 초성.ㄲ], ['T', 초성.ㅆ]]);
const 쌍자음코드 = new Set<number>(쌍자음키맵.values());
const 모음키맵 = new Map<string, number>([
    ['Y', 중성.ㅛ], ['U', 중성.ㅕ], ['I', 중성.ㅑ], ['O', 중성.ㅐ], ['P', 중성.ㅔ],
    ['H', 중성.ㅗ], ['J', 중성.ㅓ], ['K', 중성.ㅏ], ['L', 중성.ㅣ], ['B', 중성.ㅠ],
    ['N', 중성.ㅜ], ['M', 중성.ㅡ]]);
const 라틴키맵 = new Map<string, number>([
    ['Backquote', 0x60], ['1', 0x31], ['2', 0x32], ['3', 0x33], ['4', 0x34],
    ['5', 0x35], ['6', 0x36], ['7', 0x37], ['8', 0x38], ['9', 0x39],
    ['0', 0x30], ['Minus', 0x2D], ['Equal', 0x3D], ['Backspace', 0x08], ['Q', 0x71],
    ['W', 0x77], ['E', 0x65], ['R', 0x72], ['T', 0x74], ['Y', 0x79],
    ['U', 0x75], ['I', 0x69], ['O', 0x6F], ['P', 0x70], ['BracketLeft', 0x5B],
    ['BracketRight', 0x5D], ['Backslash', 0x5C], ['A', 0x61], ['S', 0x73], ['D', 0x64],
    ['F', 0x66], ['G', 0x67], ['H', 0x68], ['J', 0x6A], ['K', 0x6B],
    ['L', 0x6C], ['Semicolon', 0x3B], ['Quote', 0x27], ['Enter', 0x0A], ['Z', 0x7A],
    ['X', 0x78], ['C', 0x63], ['V', 0x76], ['B', 0x62], ['N', 0x6E],
    ['M', 0x6D], ['Comma', 0x2C], ['Period', 0x2E], ['Slash', 0x2F], ['Space', 0x20],
]);

function 한글모드(모드: 입력모드) {
    return 모드 === 입력모드.한글 || 모드 === 입력모드.종성없음;
}

function 자음([모드, 쉬프트, 키]: 키입력): number {
    return 쌍자음([모드, 쉬프트, 키]) || (한글모드(모드) && 자음키맵.get(키)) || 0;
}

function 종성자음([모드, 쉬프트, 키]: 키입력): number {
    return 한글모드(모드) && 초성to종성맵.get(자음([모드, 쉬프트, 키])) || 0;
}

function 모음([모드, 쉬프트, 키]: 키입력): number {
    const 코드 = 한글모드(모드) && 모음키맵.get(키) || 0;
    if (쉬프트 && (코드 === 2 || 코드 === 6)) {
        return 코드 + 2;
    }
    return 코드;
}

function 쌍자음([모드, 쉬프트, 키]: 키입력): number {
    return 한글모드(모드) && 쉬프트 && 쌍자음키맵.get(키) || 0;
}

function 라틴([모드, 쉬프트, 키]: 키입력): number {
    return 라틴키맵.get(키) || 0;
}

/**
 * 각각 상태는 현재 상태 코드와, 완성한 문자들, 그리고 조립중인 문자를 담고 있다.
 * 완성한 문자는 대부분의 경우 한 글자인데, 한글 조합중에 라틴문자가 오면, 한글 한 자와
 * 라틴 한자를 모두 완성 처리하기 위해 배열로 처리한다.
 */

function 라틴처리([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    if (라틴(입력)) {
        if (조립.코드.every((code) => code === 0)) {
            return [위치이동.다음, 상태코드.S0, [글자없음.라틴(라틴(입력))], 글자없음];
        } else {
            return [위치이동.다음, 상태코드.S0, [조립, 글자없음.라틴(라틴(입력))], 글자없음];
        }
    }
    return [위치이동.유지, 현재상태, 완성, 조립];
}

/**
 * 시작상태 S0에서 전이
 */
function 전이S0([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (쌍자음(입력)) {
        return [위치이동.유지, 상태.S11, 완성, 조립.새초성(쌍자음(입력))];
    } else if (자음(입력)) {
        return [위치이동.유지, 상태.S10, 완성, 조립.새초성(자음(입력))];
    } else if (모음(입력)) {
        return [위치이동.유지, 상태.S20, 완성, 조립.새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        return [위치이동.이전, 상태코드.S0, 완성, 글자없음];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

/**
 * 초성 S10에서 전이 - 초성 단자음 상태
 */
function 전이S10([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (쌍자음(입력)) {
        return [위치이동.다음, 상태.S11, [조립], 글자없음.새초성(쌍자음(입력))];
    } else if (자음(입력)) {
        if (쌍자음([모드, true, 키]) && 조립.초성 === 자음(입력)) {
            // 쌍자음으로 만들 수 있는 단자음 두번 -> 쌍자음 전환
            return [위치이동.유지, 상태.S11, 완성, 글자없음.새초성(쌍자음([모드, true, 키]))];
        } else {
            // 단자음 두번으로 쌍자음을 만들지 못할 경우 다음 글자로 이동
            return [위치이동.다음, 상태.S10, [조립], 글자없음.새초성(자음(입력))];
        }
    } else if (모음(입력)) {
        return [위치이동.유지, 상태.S20, 완성, 조립.새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        return [위치이동.유지, 상태.S0, 완성, 글자없음];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

/**
 * 초성 S11에서 전이 - 초성 쌍자음 상태
 */
function 전이S11([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (쌍자음(입력)) {
        return [위치이동.다음, 상태.S11, [조립], 글자없음.새초성(쌍자음(입력))];
    } else if (자음(입력)) {
        return [위치이동.다음, 상태.S10, [조립], 글자없음.새초성(자음(입력))];
    } else if (모음(입력)) {
        return [위치이동.유지, 상태.S20, 완성, 조립.새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        return [위치이동.유지, 상태.S10, 완성, 조립.새초성(조립.초성 - 1)];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

/**
 * 중성 S20에서 전이 - 중성 한번에 입력한 상태
 */
function 전이S20([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (종성자음(입력) && 모드 !== 입력모드.종성없음) {
        return [위치이동.유지, 상태.S30, 완성, 조립.새종성(종성자음(입력))];
    } else if (자음(입력)) {
        // 종성에 못 오는 자음. ㄸ,ㅉ
        return [위치이동.다음, 상태.S10, [조립], 글자없음.새초성(자음(입력))];
    } else if (모음(입력)) {
        const 코드 = 모음(입력);
        if (조립.중성 === 중성.ㅗ) { // ㅗ
            if (코드 === 중성.ㅏ || 코드 === 중성.ㅐ) {    // ㅘ ㅙ
                return [위치이동.유지, 상태.S21, 완성, 조립.새중성(코드 + 9)];
            } else if (코드 === 중성.ㅣ) {    // ㅚ
                return [위치이동.유지, 상태.S21, 완성, 조립.새중성(중성.ㅚ)];
            }
            return [위치이동.다음, 상태.S20, [조립], 글자없음.새중성(코드)];
        } else if (조립.중성 === 중성.ㅜ) {    // ㅜ
            if (코드 === 중성.ㅓ || 코드 === 중성.ㅔ) {
                return [위치이동.유지, 상태.S21, 완성, 조립.새중성(코드 + 10)];
            } else if (코드 === 중성.ㅣ) {
                return [위치이동.유지, 상태.S21, 완성, 조립.새중성(중성.ㅟ)];
            }
            return [위치이동.다음, 상태.S20, [조립], 글자없음.새중성(코드)];
        } else if (조립.중성 === 중성.ㅡ) {    // ㅡ
            if (코드 === 중성.ㅣ) {
                return [위치이동.유지, 상태.S21, 완성, 조립.새중성(중성.ㅢ)];
            }
            return [위치이동.다음, 상태.S20, [조립], 글자없음.새중성(코드)];
        }
        return [위치이동.다음, 상태.S20, [조립], 글자없음.새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        return [위치이동.유지,
                쌍자음코드.has(조립.초성) ? 상태.S11 : 상태.S10,
                완성, 조립.새중성(0)];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

/**
 * 중성 S21에서 전이 - 중성 두번에 입력한 상태 상태
 */
function 전이S21([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (종성자음(입력) && 모드 !== 입력모드.종성없음) {
        return [위치이동.유지, 상태.S30, 완성, 조립.새종성(종성자음(입력))];
    } else if (자음(입력) && 모드 !== 입력모드.종성없음) {
        return [위치이동.유지, 상태.S30, [조립], 글자없음.새초성(자음(입력))];
    } else if (자음(입력)) {
        return [위치이동.다음,
                쌍자음(입력) ? 상태.S11 : 상태.S10,
                [조립],
                글자없음.새초성(쌍자음(입력) || 자음(입력))];
    } else if (모음(입력)) {
        return [위치이동.다음, 상태.S20, [조립], 글자없음.새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        let 새중성 = 0;
        if (조립.중성 >= 10 && 조립.중성 <= 12) {
            새중성 = 9;
        } else if (조립.중성 >= 15 && 조립.중성 <= 17) {
            새중성 = 14;
        } else if (조립.중성 === 20) {
            새중성 = 19;
        }
        return [위치이동.유지, 상태.S20, 완성, 조립.새중성(새중성)];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

const ㄹ자음군맵 = new Map<number, number>([
    [1, 9], [16, 10], [17, 11], [19, 12], [25, 13], [26, 14], [27, 15]]);
const ㄹ자음군분리후초성맵 = new Map<number, number>([
    [9, 1], [10, 7], [11, 8], [12, 10], [13, 17], [14, 18], [15, 19]]);

/**
 * 종성 S30에서 전이 - 중성 하나로 입력상태 (쌍자음 포함)
 */
function 전이S30([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    if (자음(입력)) {
        const 코드 = 자음(입력);
        if (조립.종성 === 종성.ㄱ && 코드 === 초성.ㅅ) {
            return [위치이동.유지, 상태.S31, 완성, 조립.새종성(종성.ㄳ)];
        } else if (조립.종성 === 종성.ㄴ && (코드 === 초성.ㅈ || 코드 === 초성.ㅎ)) {
            return [위치이동.유지, 상태.S31, 완성, 조립.새종성(코드 === 초성.ㅈ ? 종성.ㄵ : 종성.ㄶ)];
        } else if (조립.종성 === 종성.ㅂ && 코드 === 초성.ㅅ) {
            return [위치이동.유지, 상태.S31, 완성, 조립.새종성(종성.ㅄ)];
        } else if (조립.종성 === 8 && ㄹ자음군맵.has(코드)) {
            return [위치이동.유지, 상태.S31, 완성, 조립.새종성(ㄹ자음군맵.get(코드)!)];
        }
        return [위치이동.다음, 상태.S10, [조립], 글자없음.새초성(자음(입력))];
    } else if (모음(입력)) {
        return [위치이동.다음, 상태.S20,
                [조립.새종성(0)],
                글자없음.새초성(종성to초성맵.get(조립.종성)!).새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        const 조립중성 = (조립.중성 >= 10 && 조립.중성 <= 12)
                        || (조립.중성 >= 15 && 조립.중성 <= 17)
                        || 조립.중성 === 20;
        return [위치이동.유지,
                조립중성 ? 상태.S21 : 상태.S20,
                완성, 조립.새종성(0)];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}

/**
 * 종성 S31에서 전이 - 자음군 입력상태
 */
function 전이S31([현재상태, 완성, 조립]: 머신상태, 입력: 키입력): 다음상태 {
    const 상태 = 상태코드;
    const [모드, 쉬프트, 키] = 입력;
    const 자음군분리 = (종: number) => {
        if (종 === 3) {
            return [1, 10];
        } else if (종 === 5 || 종 === 6) {
            return [4, 종 === 5 ? 13 : 19];
        } else if (종 >= 9 && 종 <= 15) {
            return [8, ㄹ자음군분리후초성맵.get(종)!];
        }
        return [0, 0];
    };
    if (자음(입력)) {
        return [위치이동.다음, 상태.S10, [조립], 글자없음.새초성(자음(입력))];
    } else if (모음(입력)) {
        const [남은자음, 다음자음] = 자음군분리(조립.종성);
        return [위치이동.다음, 상태.S20, [조립.새종성(남은자음)], 글자없음.새초성(다음자음).새중성(모음(입력))];
    } else if (키 === 'Backspace') {
        return [위치이동.유지, 상태.S30, 완성, 조립.새종성(자음군분리(조립.종성)[0])];
    }
    return 라틴처리([현재상태, 완성, 조립], 입력);
}


export function 상태전이([현재상태, 완성글자, 조립글자]: 머신상태, 입력: 키입력): 다음상태 {
    switch (현재상태) {
        case 상태코드.S0:
            return 전이S0([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S10:
            return 전이S10([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S11:
            return 전이S11([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S20:
            return 전이S20([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S21:
            return 전이S21([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S30:
            return 전이S30([현재상태, 완성글자, 조립글자], 입력);
        case 상태코드.S31:
            return 전이S31([현재상태, 완성글자, 조립글자], 입력);
    }
    return [위치이동. 유지, 상태코드.S0, [글자없음], 글자없음];
}

export interface 입력머신이벤트핸들러 {
    새완성글자: (글자: 글자꼴) => any;
    새조립글자: (글자: 글자꼴) => any;
    이전글자: () => 글자꼴;
}

export class 입력머신틀 {
    private 상태: 머신상태 = [상태코드.S0, [글자없음], 글자없음];
    public 입력(키: 키입력): [위치이동, 글자꼴[], 글자꼴] {
        const [위치, 새상태, 완성, 조립] = 상태전이(this.상태, 키);
        this.상태 = [새상태, 완성, 조립];
        return [위치, 완성, 조립];
    }
}

const 두번누르는중성 = new Set<number>([중성.ㅘ, 중성.ㅙ, 중성.ㅚ, 중성.ㅝ, 중성.ㅞ, 중성.ㅟ, 중성.ㅢ]);
const 두번누르는종성 = new Set<number>([
    종성.ㄳ, 종성.ㄵ, 종성.ㄶ, 종성.ㄺ, 종성.ㄻ,
    종성.ㄼ, 종성.ㄽ, 종성.ㄾ, 종성.ㄿ, 종성.ㅀ]);

export function 필요타수(글자: 글자꼴): number[] {
    if (글자 === 글자없음) {
        return [0];
    } else if (글자.한글) {
        const [초, 중, 종] = 글자.코드;
        const 초타 = 초 > 0 ? 1 : 0;
        const 중타 = 두번누르는중성.has(중) ? 2 : (중 > 0 ? 1 : 0);
        const 종타 = 두번누르는종성.has(종) ? 2 : (종 > 0 ? 1 : 0);
        return [초타, 중타, 종타];
    } else {
        return [1];
    }
}

const 초성조립맵 = new Map<초성, 초성>([
    [초성.ㄲ, 초성.ㄱ], [초성.ㄸ, 초성.ㄷ], [초성.ㅆ, 초성.ㅅ], [초성.ㅉ, 초성.ㅈ]]);
const 중성조립맵 = new Map<중성, 중성>([
    [중성.ㅘ, 중성.ㅗ], [중성.ㅙ, 중성.ㅗ], [중성.ㅚ, 중성.ㅗ], [중성.ㅝ, 중성.ㅜ],
    [중성.ㅞ, 중성.ㅜ], [중성.ㅟ, 중성.ㅜ], [중성.ㅢ, 중성.ㅡ]]);
const 종성조립맵 = new Map<종성, 종성>([
    [종성.ㄳ, 종성.ㄱ], [종성.ㄵ, 종성.ㄴ], [종성.ㄶ, 종성.ㄴ], [종성.ㄺ, 종성.ㄹ],
    [종성.ㄻ, 종성.ㄹ], [종성.ㄼ, 종성.ㄹ], [종성.ㄽ, 종성.ㄹ], [종성.ㄾ, 종성.ㄹ],
    [종성.ㄿ, 종성.ㄹ], [종성.ㅀ, 종성.ㄹ], [종성.ㅄ, 종성.ㅂ]]);

export function 입력중(지문글자: 글자꼴, 쓴글자: 글자꼴): [boolean, boolean, boolean] {
    return [초성조립맵.get(지문글자.초성) === 쓴글자.초성,
            중성조립맵.get(지문글자.중성) === 쓴글자.중성,
            종성조립맵.get(지문글자.종성) === 쓴글자.종성];
}
